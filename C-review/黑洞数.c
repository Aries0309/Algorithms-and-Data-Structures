/*黑洞数也称为陷阱数，又称“Kaprekar问题”，是一类具有奇特转换特性的数。

任何一个各位数字不全相同的三位数，经有限次“重排求差”操作，总会得到495。最后所得的495即为三位黑洞数。所谓“重排求差”操作即组成该数的数字重排后的最大数减去重排后的最小数。（6174为四位黑洞数。）

例如，对三位数207：

第1次重排求差得：720 - 27 ＝ 693；
第2次重排求差得：963 - 369 ＝ 594；
第3次重排求差得：954 - 459 ＝ 495；
以后会停留在495这一黑洞数。如果三位数的3个数字全相同，一次转换后即为0。

任意输入一个三位数，编程给出重排求差的过程。*/
#include <stdio.h>
int main(void)
{
    int a, b, c, x, y, z, n = 0;
    scanf("%d", &a);
    do
    {
        x = a / 100;
        y = a / 10 % 10;
        z = a % 10;
        if (x == y && x == z)
            printf("%d: %d - %d = %d\n", n, b, c, b - c);
        else if (x >= y && x >= z)
        {
            if (y >= z)
            {
                b = x * 100 + y * 10 + z;
                c = z * 100 + y * 10 + x;
            }
            else
            {
                b = x * 100 + z * 10 + y;
                c = y * 100 + z * 10 + x;
            }
        }
        else if (y >= x && y >= z)
        {
            if (x >= z)
            {
                b = y * 100 + x * 10 + z;
                c = z * 100 + x * 10 + y;
            }
            else
            {
                b = y * 100 + z * 10 + x;
                c = x * 100 + z * 10 + y;
            }
        }
        else if (z >= x && z >= y)
        {
            if (x >= y)
            {
                b = z * 100 + x * 10 + y;
                c = y * 100 + x * 10 + z;
            }
            else
            {
                b = z * 100 + y * 10 + x;
                c = x * 100 + y * 10 + z;
            }
        }
        n++;
        a = b - c;
        printf("%d: %d - %d = %d\n", n, b, c, a);
    } while (b - c != 495);
}
